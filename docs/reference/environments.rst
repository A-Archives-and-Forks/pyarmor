.. highlight:: none

=======================
 Building Environments
=======================

Command :command:`pyarmor` runs in :term:`build machine` to geneate obfuscated scripts and all the other required files.

Here list everything related to :command:`pyarmor`.

Above all it only runs in the `supported platforms`_ by `supported Python versions`_.

Command line options, `configuration options`_, `plugins`_, `hooks`_ and a few environment variables control how to generate obfuscated scripts and runtime files.

All the command line options and environment variables are described in :doc:`man`

Supported Python versions
=========================

.. table:: Table-1. Supported Python Versions
   :widths: auto

   ===================  =====  =========  =========  ==========  ======  =======  ==============
   Python Version        2.7    3.0~3.4    3.5~3.6    3.7~3.10    3.11    3.12+   Remark
   ===================  =====  =========  =========  ==========  ======  =======  ==============
   pyarmor 8 RFT Mode    No       No         No          Y         Y       N/y      [#]_
   pyarmor 8 BCC Mode    No       No         No          Y         Y       N/y
   pyarmor 8 others      No       No         No          Y         Y       N/y
   pyarmor-7             Y        Y          Y           Y         No      No
   ===================  =====  =========  =========  ==========  ======  =======  ==============

Supported platforms
===================

.. table:: Table-2. Supported Platforms
   :widths: auto

   ===================  ============  ========  =======  ============  =========  =======  =======
   OS                     Windows           Apple                    Linux
   -------------------  ------------  -----------------  -----------------------------------------
   Arch                  x86/x86_64    x86_64    arm64    x86/x86_64    aarch64    armv7    armv6
   ===================  ============  ========  =======  ============  =========  =======  =======
   Themida Protection        Y           No        No         No          No       No        No
   pyarmor 8 RFT Mode        Y           Y         Y          Y           Y        Y         N/y
   pyarmor 8 BCC Mode        Y           Y         Y          Y           Y        N/y       No
   pyarmor 8 others          Y           Y         Y          Y           Y        Y         Y
   pyarmor-7 [#]_            Y           Y         Y          Y           Y        Y         Y
   ===================  ============  ========  =======  ============  =========  =======  =======

.. rubric:: notes

.. [#] ``N/y`` means not yet now, but will be supported in futer
.. [#] pyarmor-7 also supports more linux arches, refer to `Pyarmor 7.x platforms`__.

.. important::

   pyarmor-7 is bug fixed Pyarmor 7.x version, it's same as Pyarmor 7.x, and only works with old license. Do not use it with new license, it may report ``HTTP 401 error``.

__ https://pyarmor.readthedocs.io/en/v7.7/platforms.html

Configuration options
=====================

There are 3 kinds of configuration files

* global: an ini file :file:`~/.pyarmor/config/global`
* local: an ini file :file:`./.pyarmor/config`
* private: each module may has one ini file in :term:`Local Path`. For example, :file:`./.pyarmor/foo.rules` is private configuration of module ``foo``

Use command :ref:`pyarmor cfg` to change options in configuration files.

.. _plugins:

Plugins
=======

.. versionadded:: 8.2

.. program:: pyarmor gen

Plugin is a Python script used to do some post-build work in generating obfuscated scripts.

Plugin use cases:

- Copy data files to output path
- Add comment to :term:`outer key` file
- Rename binary extension :mod:`pyarmor_runtime` suffix to avoid name confilcts
- In Darwin use `install_name_tool` to fix :term:`extension module` :mod:`pyarmor_runtime` couldn't be loaded if Python is not installed in the stardard path

Plugin script must define attribute ``__all__`` to export plugin name.

Plugin script could be any name.

Plugin script could define one or more plugin classes:

.. py:class:: PluginName

    .. py:staticmethod:: post_build(ctx, inputs, outputs, pack=None)

       This method is optional.

       This method is called when all the obfuscated scripts and runtime files have been geneated by :ref:`pyarmor gen`

       :param Context ctx: building context
       :param list inputs: all the input paths
       :param list outputs: all the output paths
       :param str pack: if not None, it's an executable file specified by :option:`--pack`

    .. py:staticmethod:: post_key(ctx, keyfile, expired=None, devices=None, data=None, period=None)

       This method is optional.

       This method is called when :term:`outer key` has been generated by :ref:`pyarmor gen key`

       :param Context ctx: building context
       :param str keyfile: path of generated key file
       :param long expired: expired epoch or None
       :param list devices: binding device hardware informations or None
       :param str data: binding data or None
       :param int period: period in seconds or None

    .. py:staticmethod:: post_runtime(ctx, source, dest, platform)

       This method is optional.

       This method is called when the runtime extension module ``pyarmor_runtime.so`` in the :term:`runtime package` has been generated by :ref:`pyarmor gen`.

       It may be called many times if many platforms are specified in the command line.
       :param Context ctx: building context
       :param str source: source path of pyarmor extension
       :param str dest: output path of pyarmor extension
       :param str platform: standard :term:`platform` name

To make plugin script work, configure it with script name without extension ``.py`` by this way::

    $ pyarmor cfg plugins + "script name"

Pyarmor search plugin script in these paths in turn:

- Current path
- :term:`local path`, generally ``.pyarmor/``
- :term:`global path`, generally ``~/.pyarmor/``

Here it's an example plugin script ``fooplugin.py``

.. code-block:: python

    __all__ = ['EchoPlugin']

    class EchoPlugin:

        @staticmethod
        def post_runtime(ctx, source, dest, platform):
            print('-------- test fooplugin ----------')
            print('ctx is', ctx)
            print('source is', source)
            print('dest is', dest)
            print('platform is', platform)

Store it to local path ``.pyarmor/fooplugin.py``, and enable it::

    $ pyarmor cfg plugins + "fooplugin"

Check it, this plugin information should be printed in the console::

    $ pyarmor gen foo.py

Disable this plugin::

    $ pyarmor cfg plgins - "fooplugin"

.. _hooks:

Hooks
=====

.. versionadded:: 8.2

Hook is a Python script which is embedded into the obfuscated script, and executed when the obfuscated script is running.

When obfuscating the scripts, Pyarmor searchs path ``hooks`` in the :term:`local path` and :term:`global path` in turn. If there is any same name script exists, it's called module hook script.

For example, ``.pyarmor/hooks/foo.py`` is hook script of ``foo.py``, ``.pyarmor/hooks/joker.card.py`` is hook script of ``joker/card.py``.

When generating obfuscate script by this command::

    $ pyarmor gen foo.py

``.pyarmor/hooks/foo.py`` will be inserted into the beginning of ``foo.py``.

A hook script is a normal Python script, it could do everything Python could do. And it could use 2 special function :func:`__pyarmor__` and :func:`__assert_armored__` to do some interesting work.

Note that all the source lines in the hook script are inserted into module level of original script, be careful to avoid name confilicts.

.. There is a special hook script ``.pyarmor/hooks/pyarmor_runtime.py`` will be embedded into extension `pyarmor_runtime` init function.

.. seealso:: :func:`__pyarmor__`  :func:`__assert_armorred__`

=====================
 Target Environments
=====================

Obfuscated scripts run in :term:`target device`, support platforms, arches and Python versions are same as `Building Environments`_

A few :mod:`sys` attributes and environment variables may change behaviours of obfuscated scripts.

:attr:`sys._MEIPASS`

      Borrowed from PyInstaller_, set search path for :term:`outer key`.

:attr:`sys._PARLANG`

      It's used to set runtime error language.

      If it's set, :envvar:`LANG` is ignored.

.. envvar:: LANG

      OS environment variable, used to select runtime error language.

.. envvar:: PYARMOR_LANG

      It's used to set language runtime error language.

      If it's set, both :envvar:`LANG` and :attr:`sys._PARLANG` are ignored.

.. envvar:: PYARMOR_RKEY

      Set search path for :term:`outer key`

Specialized builtin functions
=============================

.. versionadded:: 8.2

There are 2 specialized builtin functions, both of them could be used without import in the obfuscated scripts.

Generally they're used with inline marker or in the hook scripts.

.. function:: __pyarmor__(arg, kwarg, name, flag)

   `name` must be byte string ``b'hdinfo'`` or ``b'keyinfo'``

   `flag` must be ``1``

   **get hdinfo**

   When `name` is ``b'hdinfo'``, call it to get hardware information.

   `arg` could be

   - 0: get the serial number of first harddisk
   - 1: get mac address of first network card
   - 2: get ipv4 address of first network card
   - 3: get target machine name

   For example,

   .. code-block:: python

         __pyarmor__(0, None, b'hdinfo', 1)
         __pyarmor__(1, None, b'hdinfo', 1)

   In Linux, `kwarg` is used to get named network card or named harddisk. For example:

   .. code-block:: python

         __pyarmor__(0, name="/dev/vda2", b'hdinfo', 1)
         __pyarmor__(1, name="eth2", b'hdinfo', 1)

   In Windows, `kwarg` is used to get all network cards and harddisks. For example:

   .. code-block:: python

         __pyarmor__(0, name="/0", b'hdinfo', 1)    # First disk
         __pyarmor__(0, name="/1", b'hdinfo', 1)    # Second disk

         __pyarmor__(1, name="*", b'hdinfo', 1)
         __pyarmor__(1, name="*", b'hdinfo', 1)


   **get keyinfo**

   When `name` is ``b'keyinfo'``, call it to query user data in the runtime key.

   For example,

   .. code-block:: python

         __pyarmor__(0, None, b'keyinfo', 1)   # return user data (bytes)
         __pyarmor__(1, None, b'keyinfo', 1)   # return expire date (epoch)

   Raise :exc:`RuntimeError` if something is wrong.

.. function:: __assert_armored__(arg)

   `arg` is a module or callable object, if `arg` is obfuscated, it return `arg` self, otherwise, raise protection error. For example

.. code-block:: python

    m = __import__('abc')
    __assert_armored__(m)

    def hello(msg):
        print(msg)

    __assert_armored__(hello)
    hello('abc')

.. include:: ../_common_definitions.txt
